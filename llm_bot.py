#!/usr/bin/env python3
"""
AI Bot integration dla komunikatora IP
U≈ºywa OpenAI API do inteligentnych odpowiedzi
"""

import socket
import threading
import time
import json
import re
import sys
import os
from datetime import datetime
from typing import List, Dict, Optional

try:
    import openai
    OPENAI_AVAILABLE = True
except ImportError:
    OPENAI_AVAILABLE = False

# Dodaj ≈õcie≈ºkƒô do common
sys.path.append(os.path.join(os.path.dirname(__file__), '..'))

from common.protocol import Protocol, MessageType
from common.utils import validate_nick

class AIBot:
    def __init__(self, 
                 openai_api_key: str,
                 bot_name: str = "ü§ñAIBot",
                 server_host: str = "localhost", 
                 server_port: int = 12345,
                 model: str = "gpt-3.5-turbo"):
        
        self.bot_name = bot_name
        self.server_host = server_host
        self.server_port = server_port
        self.model = model
        self.socket = None
        self.connected = False
        self.running = False
        
        # OpenAI setup
        if not OPENAI_AVAILABLE:
            raise ImportError("Zainstaluj OpenAI: pip install openai")
        
        self.client = openai.OpenAI(api_key=openai_api_key)
        
        # Kontekst rozmowy i pamiƒôƒá
        self.conversation_history: List[Dict] = []
        self.user_contexts: Dict[str, List[Dict]] = {}
        self.last_message_time = {}
        
        # Konfiguracja bota
        self.config = {
            'max_history': 20,  # Maksymalna liczba wiadomo≈õci w pamiƒôci
            'response_delay': 1.0,  # Op√≥≈∫nienie przed odpowiedziƒÖ (sekundy)
            'max_response_length': 400,  # Maksymalna d≈Çugo≈õƒá odpowiedzi
            'personality': 'helpful_assistant',  # Osobowo≈õƒá bota
            'respond_to_mentions': True,  # Odpowiadaj gdy kto≈õ wspomni bota
            'respond_to_questions': True,  # Odpowiadaj na pytania
            'respond_probability': 0.3,  # Prawdopodobie≈Ñstwo odpowiedzi na zwyk≈Çe wiadomo≈õci
        }
        
        # System prompt dla r√≥≈ºnych osobowo≈õci
        self.personalities = {
            'helpful_assistant': {
                'system_prompt': """Jeste≈õ pomocnym asystentem AI w polskim czacie internetowym. 
                Odpowiadaj kr√≥tko, przyja≈∫nie i po polsku. U≈ºywaj emoji gdy to stosowne. 
                Pomagaj u≈ºytkownikom, odpowiadaj na pytania i bƒÖd≈∫ czƒô≈õciƒÖ spo≈Çeczno≈õci.""",
                'greeting': "Cze≈õƒá! Jestem AI bot ü§ñ Mogƒô pom√≥c w czacie!"
            },
            'funny_bot': {
                'system_prompt': """Jeste≈õ zabawnym botem w polskim czacie. Lubisz ≈ºarty, 
                memy i rozmowy. Odpowiadaj z humorem, u≈ºywaj emoji i bƒÖd≈∫ pozytywny. 
                Czasem opowiedz ≈ºart lub ciekawostkƒô.""",
                'greeting': "Hej! Jestem zabawny bot üòÑ Gotowy na rozmowƒô i ≈ºarty!"
            },
            'technical_expert': {
                'system_prompt': """Jeste≈õ ekspertem technicznym w polskim czacie. 
                Specjalizujesz siƒô w programowaniu, technologii i rozwiƒÖzywaniu problem√≥w. 
                Odpowiadaj precyzyjnie ale przystƒôpnie.""",
                'greeting': "Witam! Jestem tech bot üíª Pomogƒô z zagadnieniami technicznymi!"
            }
        }
        
        print(f"ü§ñ AI Bot inicjalizowany...")
        print(f"   Model: {self.model}")
        print(f"   Osobowo≈õƒá: {self.config['personality']}")
        print(f"   Serwer: {self.server_host}:{self.server_port}")

    def connect_to_server(self) -> bool:
        """≈ÅƒÖczy bota z serwerem TCP"""
        try:
            self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            self.socket.settimeout(30)
            self.socket.connect((self.server_host, self.server_port))
            
            # W≈ÇƒÖcz szyfrowanie je≈õli dostƒôpne
            try:
                from common.encryption import is_encryption_available
                if is_encryption_available():
                    encryption_password = "komunikator_secure_2025"
                    Protocol.enable_encryption(encryption_password)
                    print("üîí Szyfrowanie w≈ÇƒÖczone dla bota")
            except ImportError:
                print("‚ö†Ô∏è Szyfrowanie niedostƒôpne dla bota")
            
            # Wy≈õlij wiadomo≈õƒá JOIN
            join_message = Protocol.create_message(MessageType.JOIN, self.bot_name)
            self.socket.send(join_message.encode('utf-8'))
            
            self.connected = True
            self.running = True
            
            print(f"‚úÖ Bot po≈ÇƒÖczony z serwerem jako {self.bot_name}")
            
            # Uruchom wƒÖtek odbierajƒÖcy wiadomo≈õci
            receive_thread = threading.Thread(target=self.receive_messages)
            receive_thread.daemon = True
            receive_thread.start()
            
            # Przywitaj siƒô w czacie
            time.sleep(2)  # Poczekaj chwilƒô
            greeting = self.personalities[self.config['personality']]['greeting']
            self.send_message(greeting)
            
            return True
            
        except Exception as e:
            print(f"‚ùå B≈ÇƒÖd po≈ÇƒÖczenia bota: {e}")
            return False

    def receive_messages(self):
        """Odbiera wiadomo≈õci z serwera"""
        while self.running and self.connected:
            try:
                data = self.socket.recv(1024).decode('utf-8')
                if not data:
                    break
                
                message = Protocol.parse_message(data)
                self.process_message(message)
                
            except socket.timeout:
                continue
            except socket.error as e:
                print(f"‚ùå B≈ÇƒÖd odbierania wiadomo≈õci: {e}")
                break
            except Exception as e:
                print(f"‚ùå Nieoczekiwany b≈ÇƒÖd: {e}")
                continue
        
        self.connected = False
        print("üîå Bot roz≈ÇƒÖczony z serwera")

    def process_message(self, message: Dict):
        """Przetwarza otrzymanƒÖ wiadomo≈õƒá"""
        msg_type = message.get('type', '')
        user = message.get('user', '')
        content = message.get('content', '')
        timestamp = message.get('timestamp', '')
        
        # Ignoruj w≈Çasne wiadomo≈õci i wiadomo≈õci systemowe
        if user == self.bot_name or msg_type != MessageType.MESSAGE:
            return
        
        # Dodaj do historii konwersacji
        self.add_to_history(user, content, timestamp)
        
        # Sprawd≈∫ czy bot powinien odpowiedzieƒá
        if self.should_respond(user, content):
            # Dodaj op√≥≈∫nienie dla naturalno≈õci
            delay = self.config['response_delay']
            threading.Timer(delay, self.generate_and_send_response, [user, content]).start()

    def should_respond(self, user: str, content: str) -> bool:
        """Okre≈õla czy bot powinien odpowiedzieƒá na wiadomo≈õƒá"""
        content_lower = content.lower()
        
        # Zawsze odpowiadaj gdy kto≈õ wspomni bota
        if self.config['respond_to_mentions']:
            bot_mentions = [self.bot_name.lower(), 'bot', 'ai', 'ü§ñ']
            if any(mention in content_lower for mention in bot_mentions):
                return True
        
        # Odpowiadaj na pytania
        if self.config['respond_to_questions']:
            question_indicators = ['?', 'jak', 'dlaczego', 'co', 'gdzie', 'kiedy', 'czy', 'help', 'pomoc']
            if any(indicator in content_lower for indicator in question_indicators):
                return True
        
        # Odpowiadaj na pozdrowienia
        greetings = ['cze≈õƒá', 'hej', 'siema', 'witaj', 'hello', 'hi']
        if any(greeting in content_lower for greeting in greetings):
            return True
        
        # Losowo odpowiadaj na inne wiadomo≈õci
        import random
        if random.random() < self.config['respond_probability']:
            return True
        
        return False

    def add_to_history(self, user: str, content: str, timestamp: str):
        """Dodaje wiadomo≈õƒá do historii konwersacji"""
        message_entry = {
            'user': user,
            'content': content,
            'timestamp': timestamp
        }
        
        # Globalna historia
        self.conversation_history.append(message_entry)
        if len(self.conversation_history) > self.config['max_history']:
            self.conversation_history.pop(0)
        
        # Historia per u≈ºytkownik
        if user not in self.user_contexts:
            self.user_contexts[user] = []
        
        self.user_contexts[user].append(message_entry)
        if len(self.user_contexts[user]) > 10:  # Maksymalnie 10 wiadomo≈õci per u≈ºytkownik
            self.user_contexts[user].pop(0)
        
        self.last_message_time[user] = datetime.now()

    def generate_and_send_response(self, user: str, content: str):
        """Generuje odpowied≈∫ AI i wysy≈Ça jƒÖ"""
        try:
            # Przygotuj kontekst
            context = self.prepare_context(user, content)
            
            # Wygeneruj odpowied≈∫
            response = self.generate_ai_response(context)
            
            if response:
                # Ogranicz d≈Çugo≈õƒá odpowiedzi
                if len(response) > self.config['max_response_length']:
                    response = response[:self.config['max_response_length']] + "..."
                
                # Dodaj prefix dla odpowiedzi na konkretnƒÖ osobƒô
                if user in content or any(mention in content.lower() for mention in [self.bot_name.lower(), 'bot']):
                    response = f"@{user} {response}"
                
                self.send_message(response)
                print(f"ü§ñ Odpowied≈∫ dla {user}: {response[:50]}...")
            
        except Exception as e:
            print(f"‚ùå B≈ÇƒÖd generowania odpowiedzi: {e}")
            # Fallback response
            fallback_responses = [
                "Przepraszam, mam problem z odpowiedziƒÖ üòÖ",
                "Hmm, nie jestem pewien jak odpowiedzieƒá ü§î",
                "Spr√≥buj zapytaƒá ponownie üîÑ"
            ]
            import random
            fallback = random.choice(fallback_responses)
            self.send_message(fallback)

    def prepare_context(self, user: str, content: str) -> str:
        """Przygotowuje kontekst dla AI"""
        personality = self.personalities[self.config['personality']]
        
        # Historia ostatnich wiadomo≈õci
        recent_history = ""
        for msg in self.conversation_history[-5:]:  # Ostatnie 5 wiadomo≈õci
            recent_history += f"{msg['user']}: {msg['content']}\n"
        
        # Kontekst u≈ºytkownika
        user_context = ""
        if user in self.user_contexts:
            user_msgs = self.user_contexts[user][-3:]  # Ostatnie 3 wiadomo≈õci u≈ºytkownika
            for msg in user_msgs:
                user_context += f"{msg['content']}\n"
        
        context = f"""
{personality['system_prompt']}

Ostatnia historia czatu:
{recent_history}

Ostatnie wiadomo≈õci od {user}:
{user_context}

Aktualna wiadomo≈õƒá od {user}: {content}

Odpowiedz kr√≥tko i naturalnie po polsku. Maksymalnie 2-3 zdania.
"""
        return context

    def generate_ai_response(self, context: str) -> Optional[str]:
        """Generuje odpowied≈∫ za pomocƒÖ OpenAI API"""
        try:
            response = self.client.chat.completions.create(
                model=self.model,
                messages=[
                    {"role": "user", "content": context}
                ],
                max_tokens=150,
                temperature=0.7,
                frequency_penalty=0.5,
                presence_penalty=0.3
            )
            
            return response.choices[0].message.content.strip()
            
        except Exception as e:
            print(f"‚ùå B≈ÇƒÖd OpenAI API: {e}")
            return None

    def send_message(self, content: str):
        """Wysy≈Ça wiadomo≈õƒá do czatu"""
        if not self.connected:
            return
        
        try:
            message = Protocol.create_message(MessageType.MESSAGE, self.bot_name, content)
            self.socket.send(message.encode('utf-8'))
        except Exception as e:
            print(f"‚ùå B≈ÇƒÖd wysy≈Çania wiadomo≈õci: {e}")

    def send_command(self, command: str):
        """Wysy≈Ça komendƒô do serwera"""
        if not self.connected:
            return
        
        try:
            message = Protocol.create_message(MessageType.MESSAGE, self.bot_name, command)
            self.socket.send(message.encode('utf-8'))
        except Exception as e:
            print(f"‚ùå B≈ÇƒÖd wysy≈Çania komendy: {e}")

    def change_personality(self, personality: str):
        """Zmienia osobowo≈õƒá bota"""
        if personality in self.personalities:
            self.config['personality'] = personality
            greeting = self.personalities[personality]['greeting']
            self.send_message(f"üîÑ Zmieni≈Çem osobowo≈õƒá! {greeting}")
            print(f"üé≠ Zmieniono osobowo≈õƒá na: {personality}")
        else:
            available = ', '.join(self.personalities.keys())
            print(f"‚ùå Nieznana osobowo≈õƒá. Dostƒôpne: {available}")

    def get_stats(self) -> Dict:
        """Zwraca statystyki bota"""
        return {
            'connected': self.connected,
            'total_conversations': len(self.conversation_history),
            'unique_users': len(self.user_contexts),
            'personality': self.config['personality'],
            'model': self.model
        }

    def disconnect(self):
        """Roz≈ÇƒÖcza bota z serwera"""
        if self.connected:
            try:
                goodbye_message = "üëã Bot siƒô roz≈ÇƒÖcza. Do zobaczenia!"
                self.send_message(goodbye_message)
                time.sleep(1)
                
                leave_message = Protocol.create_message(MessageType.LEAVE, self.bot_name)
                self.socket.send(leave_message.encode('utf-8'))
            except:
                pass
            
            self.running = False
            self.connected = False
            
            try:
                self.socket.close()
            except:
                pass
            
            print("üëã Bot roz≈ÇƒÖczony")

def main():
    """G≈Ç√≥wna funkcja - interaktywny launcher bota"""
    print("ü§ñ AI Bot dla komunikatora IP")
    print("=" * 40)
    
    if not OPENAI_AVAILABLE:
        print("‚ùå Brak biblioteki OpenAI!")
        print("Zainstaluj: pip install openai")
        return
    
    # Pobierz API key
    api_key = "REMOVEDt6Ry0vwjZkSxtUvyqQEx8SQtYo_hE4_MiZ_v27-k1OOp1iqfCh0sfQO5AkL3_T3BlbkFJzjBKdNye74-BEhpXjNEgSn3XZzXi7WYGCAOrocUgazBM19o_xl0zoK-nFEhp-mMJgfuuvfqE4A"
    if not api_key:
        print("‚ùå API key jest wymagany!")
        return
    
    # Konfiguracja bota
    bot_name = input("ü§ñ Nazwa bota (Enter = AIBot): ").strip() or "ü§ñAIBot"
    
    print("\nüé≠ Dostƒôpne osobowo≈õci:")
    personalities = ['helpful_assistant', 'funny_bot', 'technical_expert']
    for i, p in enumerate(personalities, 1):
        print(f"   {i}. {p}")
    
    try:
        choice = int(input("Wybierz osobowo≈õƒá (1-3): ")) - 1
        personality = personalities[choice] if 0 <= choice < len(personalities) else 'helpful_assistant'
    except:
        personality = 'helpful_assistant'
    
    # Utw√≥rz i uruchom bota
    try:
        bot = AIBot(
            openai_api_key=api_key,
            bot_name=bot_name,
            model="gpt-3.5-turbo"
        )
        bot.config['personality'] = personality
        
        if bot.connect_to_server():
            print("\n‚úÖ Bot uruchomiony pomy≈õlnie!")
            print("Dostƒôpne komendy:")
            print("   'stats' - poka≈º statystyki")
            print("   'personality <nazwa>' - zmie≈Ñ osobowo≈õƒá")
            print("   'quit' - zako≈Ñcz bota")
            print()
            
            # Pƒôtla komend
            while bot.running:
                try:
                    cmd = input().strip().lower()
                    
                    if cmd == 'quit':
                        break
                    elif cmd == 'stats':
                        stats = bot.get_stats()
                        print(f"üìä Statystyki: {stats}")
                    elif cmd.startswith('personality '):
                        new_personality = cmd.split(' ', 1)[1]
                        bot.change_personality(new_personality)
                    elif cmd:
                        print("‚ùì Nieznana komenda")
                        
                except KeyboardInterrupt:
                    break
                except EOFError:
                    break
            
            bot.disconnect()
        else:
            print("‚ùå Nie uda≈Ço siƒô po≈ÇƒÖczyƒá bota z serwerem")
            
    except KeyboardInterrupt:
        print("\nüõë Bot zatrzymany przez u≈ºytkownika")
    except Exception as e:
        print(f"‚ùå B≈ÇƒÖd bota: {e}")

if __name__ == "__main__":
    main()